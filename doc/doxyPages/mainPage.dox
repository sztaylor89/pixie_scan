/** \mainpage Pixie16 Analysis Software

  \author Sean Liddick
  \author David Miller
  \author S. V. Paulauskas
  \author K. A. Miernik
  \version code - 3.0, manual - alpha v3

  \section ql Quick Links
  \subpage useman \n
  \subpage devman \n
  \subpage refman \n

  \section briefinto Brief Introduction
  This software was written at the University of Tennessee at Knoxville by
  members of the <a href="http://www.phys.utk.edu/expnuclear/">Experimental
  Nuclear Structure Group</a>. The software analyzes data from the Pixie-16
  data acquisition system produced by XIA, LLC. The recognized data format is
  currently .ldf, which are produced by the
  <a href="ftp://ftp.phy.ornl.gov/pub/upak/Linux/"> HRIBF/ORNL data acquisition
  libraries</a>. The code is capable of processing a variety of detector types,
  and is written in a modular format such that the code can be easily adapted
  to a variety of experimental setups.

  This code is the work of many people, their names are (hopefully) documented
  in the codes they wrote, and in the documentation files. If your name is
  missing or you have a contribution, please contact the code maintainers.

  You are currently viewing the main page of the doxygen generated manual. This
  manual will hopefully be kept relatively up to date, but there are no
  promises. The manual is divided into three parts: a \ref useman, a
  \ref refman, and a \ref devman.
*/

/******************************************************************************/

/** \page useman User's Manual
  - An \subpage philosophy of the Pixie16 code
  - A description of the \subpage directory
  - A \subpage quickstart Guide
  - An explanation of the \subpage xmlconfig
  - A \subpage faq
  - Some \subpage codewarn about the code
  - A \subpage primer for those who have never seen C++
*/

/******************************************************************************/

/** \page codewarn Warnings

  This section provides a list of warnings that appear throughout the manual.
  If you can not determine why something has either failed or produced incorrect
  results look at the list of warnings to see if it has been mentioned.

  \warning C++ index numbering starts at 0 not at 1 as in FORTRAN.
  Let me repeat since this causes many problems if forgotten.
  C++ indexing numbering starts at 0 not at 1 as in FORTRAN.
  \warning If you are not using ROOT then the flags USEROOT and
  STANDALONEROOT should be commented out in the Makefile.
  \warning If you have RMS DSSD data taken after March 20th 2008 then
  most likely the new pixie16 readout was used and the flag -Dnewreadout
  should be set in the Makefile.

*/

/******************************************************************************/

/** \page directory Directory Structure
  The pixie16 analysis is contained in the base directory "pixie_scan". You
  should see at a minimum the following set of files and directories.
  \section dir-filelist File List
  \subsection dir-xmlconfig Confix.xml
  This is a symbolic link to one of the configuration files in
  \ref dir-config. You can change the configuration for the program by
  changing where this link points.
  \subsection dir-copy COPYRIGHT
  This file contains the copyright information for the software. It should be
  distributed with each release.
  \subsection dir-license LICENSE
  This file contains the licensing information for the software. It should be
  distributed with any distribution or piece of the code.
  \subsection dir-readme README.md
  The README contains useful information about how to get started (such as
  making this documentation). It also contains information on who to contact
  with issues or questions.
  \subsection dir-todo TODO
  The TODO contains exactly what you think. If you have suggestions, or tackle
  one of the projects in this directory please let us know!
  \subsection dir-make Makefile
  This is a <a href="http://www.gnu.org/software/make/manual/make.html">
  GNU Makefile</a>, and is responsible for compilation of the program.

  \section dir-dirlist Directory Listing
  \subsection dir-ban bananas/
  This directory contains a test banana file that can be used as a template
  to use bananas with the scan code.
  \subsection dir-config config/
  This directory contains some of the user contributed configuration files.
  These files contain all of the configuration information that is necessary
  to analyze data. For an example file, see \ref xmlconfig.
  \subsection dir-doc doc/
  This directory contains the Doxyfile, and the other files necessary for the
  generation of this documentation. Once the documentation has been generated
  it will be located in the sub directories: html/ and latex/
  \subsection dir-inc include/
  This directory contains all of the ".hpp" files.
  \subsection dir-obj obj/
  This directory is made by the Makefile during compilation. It holds all of
  the object files for the program.
  \subsection dir-scan scan/
  This directory contains all of the ".f" files. In principle, it is never
  necessary for a general user (or even a developer) to modify these files.
  \subsection dir-scripts scripts/
  This directory contains useful scripts for using the program, either for
  the running of files, or scripts useful for the use of DAMM.
  \subsection dir-src src/
  This directory contains all of the ".cpp" files.
*/

/******************************************************************************/

/** \page faq FAQ

  This FAQ will be filled based on suggestions accumulated during
  the manual beta phase.

*/

/******************************************************************************/

/** \page philosophy Overview
  \section overview-v3 Version 3 Overview
  The code has managed to get to its next major revision. This has not been as
  extensive overhaul as was done with v2; however, there have still been
  significant changes done to the code. These changes have been necessary to
  keep the code useful and relevant to the current directions of the research
  group. Unfortunately, this has also caused the a break in backwards
  compatability with the previous versions of the map2.txt and cal.txt.

  \section overview-v2 Version 2 Overview
  The rewrite of the analysis codes was undertaken for a variety of
  reasons including:
  - Provide a consistent framework for event processing.
  - Take advantage of C++ features.
  - Enable the inclusion of ROOT as a post experimental processing tool.
  - Provide a route for adding new detectors and/or features that
    do not require alterations significant portions of the code.

  \section analysisover Analysis Overview
  In the Pixie16 analysis the basic unit of information is the channel.
  For each channel that triggers the acquisition the channel
  identification, energy, time, and trace (if applicable) are grouped
  together and sorted according to the times at which they occur (based
  on the Pixie16 clock).  The time sorted
  list of channels is then scanned and channels that fall within a
  certain time window are grouped together into events.  The events
  are subsequently processed in two stages.  The first stage operates channel
  by channel within the event and performs such operations as
  calibrations and raw parameter plotting and should not be altered.
  The second level of processing is the experiment specific event
  processing and includes such activities as correlations between
  implant events and decay events.  This section section should be
  altered according to experimental need.

  Below is the data analysis flow chart, it attempts to describe in general
  terms how the analysis proceeds. (needs revision).

  \image latex analysisflow.eps
  \image html analysisflow.jpg

  \section evcreat Event Creation
  For each buffer that is collected (from either a ldf file or an
  online source) the SCAN routine invokes the hissub_() function.
  The hissub_(), hissub_sec(), and ReadBuffData() functions serve
  to ultimately reconstruct a spill of Pixie16 data (i.e. a read of
  all Pixie16 modules) and sort the channels that triggered according
  to their times.

  ScanList() is called on the time sorted event list to group channels
  with similar times into events, store these channels in the variable
  rawevent and pass them on for further processing.

  \section experinde Experiment Independent Processing
  In the function DetectorDriver::ProcessEvent(), the RawEvent is processed.
  Each channel is checked against its threshold value read in during
  initialization from the \ref xmlconfig and calibrated using ThreshAndCal().
  The function ThreshAndCal() also keeps track of the multiplicities
  of different detector types and the maximum energy deposited into each
  detector type.  The raw and calibrated energies are then plotted using
  the functions PlotRaw() and PlotCal() using the DAMM spectra numbers
  read in from the \ref xmlconfig. This is the end of general event processing
  and should not be altered between experiments.

  \section experde Experiment Dependent Processing
  The next step in the event processing is the experiment specific tasks
  and these will vary for different setups but include such
  tasks as determining correlations between decays and implants.

  \section over-plot Plotting
  Once all event processing has finished various plotting routines are
  invoked for creating the DAMM spectra we all know and love.
*/

/******************************************************************************/

/** \page primer Primer
  In this section I will attempt to provide a rough description
  of the aspects of C++ that are being used in the analysis code
  that someone who has never seen C++ before may not recognize.
  Described here are
  - classes
  - pointers
  - vectors
  - and maps

  For more information on any of the topics mentioned here you are referred to
  the fantastic resource <a href="http://www.cplusplus.com/">cplusplus.com</a>.
  This webpage has many thorough descriptions of the ideas presented here, as
  well as, a complete method listing for the STL templates discussed.

  \section Classes Classes
  The C++ code is structured around classes.  Classes are very similar
  to structures in C, and are objects into which data is placed or
  actions are performed. Functions that are contained within classes are called
  "methods". For example, the class RawEvent is the basic object into which all
  event data will be placed in the analysis. Another example is the class
  GeProcessor, which performs much more complex manipulations of data that is
  taken using Ge detectors. In the analysis, all classes consist of two
  different files: a '.hpp' file, and a '.cpp' file. The '.hpp' file defines
  the class, its data members, and the methods that allow a user to manipulate
  the data members. The ".cpp" file contains the code necessary for the class
  to do what you want. The following code shows an example for the class called
  ChanEvent that contains the information for each channel that triggered.
  Below, we list the content of ChanEvent in its entirety.

  \include ChanEvent.hpp

  In the ChanEvent example, all the data members are defined as
  private and methods that act on the data members are public.
  This means that only the methods belonging to this class such
  as GetEnergy() can access the private data members.  This prevents
  the variables from being inadvertently altered by a different
  portion of the analysis code.  I've tried to keep all data members
  private but haven't in all cases just for simplicity (for example
  see the RawEvent class in the RawEvent.hpp file).

  The arguments that must be passed to a method are defined between the
  parenthesis after the method's name.  Thus, the method SetEnergy() must be
  provided a double-precision numerical value in order to work properly and
  would look like the following:
  \code
  chanEvent.SetEnergy(3.1416);
  \endcode
  The other important aspect of the methods are their return values, which is
  defined before the method name.  For example, the method GetEnergy()
  returns the value contained in the variable energy which is a double.
  Therefore to correctly retrieve the value you need to use a double.
  \code
  double tempEnergy = chanEvent.GetEnergy();
  \endcode
  Arguments to methods and results thereof are not limited to basic data types
  (int, double, char, ...) but can include other objects as well.
  In the method, GetChanID() method an Identifier object is returned.
  When using any of the methods make sure you know what type of argument
  is required.

  Methods that are defined in the ".hpp" file of the class are said
  to be defined "inline".  Most of the methods in ChanEvent are
  defined inline. One exception is ZeroVar() which is defined
  in the corresponding '.cpp' file; a portion of which is shown below:

  \snippet ChanEvent.cpp Zero Channel

  The only exception to this *.hpp and *.cpp pattern is PixieStd.cpp
  No class is defined for PixieStd because the main function
  hissub_ is called from the FORTRAN scan program.  A class could
  probably be constructed but is not strictly necessary in this case.

  \section Pointers Pointers
  Pointers are both an incredibly powerful feature of C++ and the easiest
  way to screw up the code.  The two types of pointers in C++ are a
  pointer by value and a pointer by reference.  A pointer by value is
  declared by an '*' in the C++ code and points to the value contained
  in a variable.  A pointer by reference is
  declared by an '&' in the C++ code and points to the memory location
  where a variable is stored. An example usage is:
  \code
  ChanEvent eventList[100];
  // ...
  ChanEvent *chan;
  chan = &eventList[1];
  \endcode
  In this section of code a pointer by value 'chan' is created that that
  will point to a ChanEvent object. The second line puts the memory
  location of eventList[1] (a ChanEvent object) into the pointer
  chan.  In this way it is possible to perform actions on chan and have
  it affect the values contained in the variable eventList[1].

  Functions also rely heavily on pointers.  By default when a C++
  function is passed a variable a local copy is created inside the
  function.  This means that if a value is passed to a function in
  this manner the function can use the value and alter it but after
  the function is finished the local copy of the value disappears,
  and the original is not affected.  In general, it is far more useful
  to have a function act on and permanently alter the original value.
  This is where pointers are useful.  A pointer by reference or value can be
  passed to a function and actions on the pointer will affect the
  original data.  The passing of pointers is also much less computationally
  intensive speeding up the data analysis.  For example, a function
  declared to receive a pointer by reference would look like:
  \code
  int DetectorDriver::ThreshAndCal(ChanEvent *chan);
  \endcode
  Where a reference to the variable passed to the function is received.

  \section Vector Vector
  The vector class is part of the STL (standard template library) that
  is used in the analysis.  A vector is essentially a dynamically
  expandable array.  A vector variable is defined as
  \code
  vector<int> intVec;
  \endcode
  where intVec is declared as a vector that contains integer values.
  The two common functions that are used to act on vectors include the
  push_back and clear functions.
  \code
  intVec.push_back(2);
  intVec.push_back(5);
  intVec.clear();
  \endcode
  The push_back function inserts a value at the end of the vector.
  In this example the first element of the vector intVec
  will have a value of 2 and the second element is 5.  The clear()
  function removes all entries in a vector and is extensively used
  in the code to zero the various vectors that are used.  The values
  of a vector can be retrieved in two different ways.  First, you
  can ask for a specific element using the same syntax as an array, thus
  \code
  cout << intVec[1] << endl;
  \endcode
  will print out a value of 5.

  \warning C++ index numbering starts at 0 not at 1 as in FORTRAN.
  Let me repeat since this causes many problems if forgotten.
  C++ index numbering starts at 0 not at 1 as in FORTRAN.

  The second way to retrieve a value from a vector is through an iterator.
  This is a pointer that can be pointed any location in the array to
  retrieve the value at that location.  The following section of code
  would loop over the intVec from beginning to end and print the value
  of the element.  Note the incrementing of the iterator iv using iv++
  to go to the next element. Using iterators is, by far, the safest way to
  access the contents of the vector because an out of bound failure is much
  more descriptive than simply "Segmentation Fault".

  \code
  vector<int>::iterator iv;
  for(vector<int>::iterator it = intVec.end(); it != intVec.begin(); it++) {
    cout << *it << endl;
  }
  \endcode

  \section Map Map
  The map is the other STL feature used in the code.  The map
  allows an association between an unique key and a value.
  It is defined as
  \code
  map<string,int> stringIntMap;
  \endcode
  In this example the key is a string and the associated value is
  an int.  To create a map you have to make pairs of the keys and values
  as in the following example.
  \code
  stringIntMap.insert(make_pair("dssd",2));
  stringIntMap.insert(make_pair("ge",15));
  \endcode
  In this example the key "dssd" is associated with an integer of 2
  and the key "ge" is associated with an integer of 15.  The
  associated values can be retrieved either by a direct access
  using the key or using of the find function.
  \code
  int temp;
  temp = stringIntMap["dssd"];

  int temp1;
  temp1 = stringIntMap.find("ge");
  \endcode
  where temp and temp1 will return 2 and 15 respectively.  While
  associating strings with integers is not very useful, a map of
  strings associated with objects is a powerful method to associate
  an unknown number of detector types with data objects as is done
  in the pixie16 analysis.

  \warning   I (SNL) am not a C++ expert! It is possible that in the analysis
  code things are done inefficiently.  Also, the descriptions I have given
  above may not be completely accurate but instead reflect a lack of
  understanding on my part.  Keep that in mind when reading the manual
  and the code.  If you think things could be done differently for
  clarity or processing speed please let me know.

  \warning I (DTM) might be a C++ expert.
  \warning I (SVP) might be a C++ fanboy.
*/

/******************************************************************************/

/** \page quickstart Quickstart
  \section qs-overview Overview
  Here you will find information on how to quickly start using this software.
  We will be working under the assumption that you have no desire to know the
  inner workings of the code, but simply want to get some graphs to look at.
  Because of the major overhauls the original guide is no longer relevant for
  this software. If you have an older version of the code, I refer you to the
  \subpage quickstart-v1.

  This guide will assume that you are not going to be using ROOT to perform the
  analysis. However, we will assume that you will be looking at data that
  requires high resolution timing algorithms. This is the most common type of
  user at this point, if you do not require this analysis you can simply not
  follow those instructions. We will also assume that you have compiled the
  documentation successfully, otherwise you wouldn't be reading this...

  Let's assume that we have a simple TOF style measurement going. We'll have
  three channels: two for VANDLE and one for our start detector.

  \section qs-prerequisites Prerequisites
  The code has a number of prerequisites that need to be met in order for you
  to begin. Here is a handy check-list:
  - <a href="ftp://ftp.phy.ornl.gov/pub/upak/Linux/">HRIBF/ORNL Libraries</a> -
    These need to be compiled and installed on the analysis computer. Please be
    aware that the installation of these files is not supported by the
    development team of this software. If you ask nicely they may help.
  - <a href="https://www.gnu.org/software/gsl/">GNU Scientific Library</a> -
    This software is usually available as a software package from your favorite
    Linux distro. It is necessary for the high-resolution timing algorithms, if
    you do not need them, nor will need them in the future, you can skip this
    one.

  \subsection qs-env Environment Preparation
  If you have successfully installed the prerequisites then you are now ready
  to prepare your Linux environment. You should add the following information
  into your ".bashrc", which is usually located in the ${HOME} directory of your
  username.

  \code
    export HHIRF_DIR=/absolute/path/to/hhirf
    export ACQ2_LIBDIR=/absolute/path/to/acq2/lib
    export HHIRF_GFORTRAN=1
    export EXTRA_PROCESSORS=/absolute/path/to/extra/processors
  \endcode

  You should replace "/absolute/path/to" with the proper absolute path to the
  two directories. The last line in the above code is depends on the FORTRAN
  compiler that was used to compile the HRIBF libraries. The two you are likely
  to encounter are 'g77' and 'gfortran'. If you are unsure about the
  installation, contact your system admin.

  When you are finished making the necessary changes to the '.bashrc', remember
  to source it.
  \code
    source ~/.bashrc
  \endcode

  \section compile Compilation
  Moving right along, now we are ready to modify the Makefile to the specific
  installation. There are a number of flags in the upper part of the Makefile
  that you can modify to suit your needs. The full list of these flags can be
  found in \ref makeflags. For now, we just need to make sure that the
  "PULSEFIT" flag is uncommented.

  \section qs-prepconfig Prepare Configuration File
  Now comes the most important part. This one is going to be the biggie, the
  whole mamma-jamma. The configuration file controls the whole operation now.
  For a complete overview of the configuration, see the page \ref xmlconfig.

  __NOTE: This file is read at runtime, you do not have to recompile when you
  make changes here!!__

  \subsection qs-author Author Node
  First, you should update the author information and description. This is not
  strictly necessary, but it makes it nicer when you are trying to figure out
  who made the file, and what they were trying to do.

  \subsection qs-global Global Parameters Node
  We are assuming you want to look at VANDLE related data, so you're going to
  want to make sure that the Revision version is set to "F" for the Pixie16-250
  modules.

  You can also change the "energyContraction" and "eventWidth" here. For now,
  we will assume you're happy with whatever was there when you got the file.
  Some common values are 1e-6 s for eventWidth and 1.0 for the
  energyContraction.

  \subsection qs-driver Setup the Detector Driver Node
  __OK, now we're onto the serious stuff, pay attention!__
  The node DetectorDriver holds the various Processors and Analyzers that you
  are going to be using for the analysis. For our simple example we will be
  wanting the following pieces:
  \code
    <Processor name="BetaScintProcessor"/>
    <Processor name="VandleProcessor" types="small" res="2" offset="200"/>

    <Analyzer name="WaveformAnalyzer"/>
    <Analyzer name="FittingAnalyzer"/>
  \endcode

  The two processor lines define the classes that will handle the manipulation
  of the data to measure our ToF. The analyzers, work specifically on the
  traces, and these two will provide the high resolution timing. There are some
  of the processors that take arguments into their constructors (Ge, Vandle),
  information on these arguments can be found in the pages for the respective
  class.

  In some analysis, you do not need to define multiple processors to handle
  information. For example, the VandleProcessor does not need the Beta or
  Double Beta processors defined in order to perform time-of-flight
  calculations. This is because these processors pull the necessary detector
  summaries themselves and build the required information. In these scenarios,
  you may simply define the VandleProcessor, unless you require histograms built
  in the Beta or Double Beta processors.

  \subsection qs-map Setup the Map Node
  The Map node tells the program what type of detector is plugged into a given
  Module/Channel combination. We have moved to this scheme since we now define
  both the energy calibration and walk calibration at this point. The tags for
  a channel are now defined as a comma separated list inside the "tags" key.
  Below is the sample code for our current example:
  \code
    <Module number="0">
        <Channel number="0" type="scint" subtype="beta">
            <WalkCorrection model="None">
            </WalkCorrection>
        </Channel>
        <Channel number="2" type="vandle" subtype="small" tags="left" numStarts="2">
            <WalkCorrection model="None">
            </WalkCorrection>
        </Channel>
        <Channel number="3" type="vandle" subtype="small" tags="right">
            <WalkCorrection model="None">
            </WalkCorrection>
        </Channel>
    </Module>
  \endcode

  None of our channels will be corrected for walk, or energy calibrated. This
  example may be updated in the future to add in a clover.

  \subsection qs-tcal TimeCalibration Node Setup
  We are now ready to input the timing calibrations. These calibrations are
  used to align the gamma prompts for the ToF measurement. In addition, this
  section defines the physical position of the bar relative to the initial
  position of the measured particle (gamma, neutron, etc.). This calibration
  differs from the previous one, as it is done on a bar-by-bar basis and not
  per channel.

  If you do not include a calibration for a channel into this node, the program
  will provide a default calibration of 0.0 for all offsets. In addition, any
  of the offsets that are left out of the correction, for example if you did not
  measure an "xoffset", it will automatically be set to zero. This removes the
  necessity for the declaration of <strong>all</strong> of the detectors in the
  analysis.

  Finally, the program now recognizes more than two start detectors. This is
  done through a list of "tofoffsets". Please refer to the sample code below,
  as well as, the sample configuration: config/Config.xml.example. The "loc"
  field in the start nodes denote the location of the starts. In the event that
  the start is a bar style detector, this will refer to the bar number. For
  a detailed description of these variables refer to \subpage timecal.

  Inside the TimeCalibration node we will have the following code:
  \code
    <Vandle>
        <small>
            <Bar number="0" z0="50.5" xoffset="1.0" zoffset="0.00"
                lroffset="-5.70784">
                    <start loc="0" offset="2.90192"/>
                    <start loc="1" offset="-6.52371"/>
                    <start loc="2" offset="1.23556"/>
                    <start loc="3" offset="-5.56573"/>
            </Bar>
        </small>
    </Vandle>
  \endcode

  You will find a detailed description of these variables in the
  \subpage timecal section.

  \subsection qs-timing Timing Node Setup
  The Timing node contains all of the information necessary for the successful
  extraction of the high resolution timing from a trace. It defines things
  such as the trace length and delay, the ranges for the waveform, and the
  fitting parameters for various detectors. The most important things to update
  in this section are the TraceDelay and TraceLength. Please note the units that
  are in each of the parameters.

  \subsection qs-treecorr TreeCorrelator Node Setup
  We will not be using the TreeCorrelator for this example, refer to
  \subpage treecorr for more info on this.

  \subsection qs-notebook NoteBook Node Setup
  Finally, you can change the output information from the notebook if you'd
  like. This is not a critical step.

  \section qs-eventcreat Event Creation
  Events are created by grouping together channels which triggered at
  similar times.  This time window is controlled by the variable EventWidth
  located in the Global node of Config.xml. If two successive channels in the
  list are within "EventWidth" time, they are grouped together in an event.
  The variable is in units of Pixie16 clock ticks and must be multiplied by
  the appropriate sampling time to obtain the event width in ns.  Please note
  that the "EventWidth" time window is only applied to successive events.
  Thus it is possible (depending on the total trigger rate) to have events that
  are longer than the specified time window.

  \section qs-eventret Retrieving Information from the Event
  After an event has been created it is sent for processing.  The first
  step of processing is to calibrate the individual channels and summarize
  the information contained in the event.  For each detector type that is
  present in the event an object called DetectorSummary is created.
  This object holds detector related information such as the energy,
  timestamp, and the multiplicity of the detector among other things.  For
  example, the following command will retrieve energy of the scint in the event.
  \code
  double energy = revt.GetSummary("beta_scint:beta")->GetList().begin()->GetEnergy();
  \endcode
  where revt is the name of the variable holding the raw event information
  and energy will contain the energy of the scintillator.

  To retrieve the multiplicity associated with VANDLE ends use
  the following command:
  \code
  int fmult = revt.GetSummary("vandle")->GetMult();
  \endcode

  The reference manual can provide a list of all commands to retrieve
  information from the detector_summary or the rawevent.

  \section qs-plotting Plotting
  All plotting is controlled through the "plot" function defined in
  DeclareHistogram. This function is a C++ wrapper that has been
  placed around the DAMM count1cc and set2cc subroutines.  This allows for
  the code to be easily changed between damm and ROOT histograms.  For
  those using DAMM to view the output of the analysis all plots are created
  in the "drrsub.f" file located in the scan directory.

  In order to plot into a histogram one must first define it in the DeclarePlots
  method of the used Processor. In addition, each Processor has a specific range
  of DAMM IDs that it is allowed to use. This is defined in the DammPlotIds.hpp.

  To define a 1D and a 2D histogram, you must first define the variables for
  the histogram numbers:
  \code
    namespace dammIds {
        namespace vandle {
            D_ENERGY_BETA = 0;
            DD_ENERGY_TIME = 1;
            DD_BETA_TRACE = 2;
        }
    }
  \endcode

  This is generally found near the top of the '.cpp' file of interest. For the
  BetaScintProcessor, this will create histograms with IDs 2050, 2051, and 2052.
  We can now define the histograms themselves in the DeclarePlots method.

  \code
    DeclareHistogram1D(D_ENERGY_BETA, SA, SA, "Beta Energy");
    DeclareHistogram2D(D_ENERGY_BETA, SA, SA, "Beta Energy vs Time");
    DeclareHistogram2D(D_ENERGY_BETA, SA, SA, "Beta Traces");
  \endcode

  SA is a constant defined for compatibility with DAMM, see DammPlotIds.hpp for
  their definitions.

  To plot a one dimensional histogram of energies:
  \code
    plot(D_ENERGY_BETA,energy);
  \endcode
  You can send any type of numerical value to the plot function.  The
  variable is rounded into an integer before being passed to the DAMM
  plotting functions. A two dimensional histogram is plotted with the command
  \code
    plot(DD_ENERGY_TIME,energy, time);
  \endcode
  and a three dimensional histogram (plotting a trace for example) uses
  the command
  \code
    plot(DD_BETATRACE, xval, row, traceval);
  \endcode

  There are numerous examples in the code on how to do this.

  \section qs-programexec Program Execution
  After the compilation has completed successfully the executable pixie_ldf_c
  will be present.  Run the pixie_ldf_c program as you would any other program:
  \verbatim
  ./pixie_ldf_c hisname
  \endverbatim
  Where "hisname" is the name of the damm histogram that will be created. At the
  scanor prompt load in the appropriate ldf file as follows
  \verbatim
  SCANOR->file tutorial/tutorial.ldf
  \endverbatim
  Next start the analysis with the following command
  \verbatim
  SCANOR->go
  \endverbatim

  After starting a variety of output should be printed to the screen.
  The first lists all the detectors that are being used in the analysis.
  This includes information about what is happening at various stages of the
  code, the status of reading in the configuration, and the creation of the
  detector summaries.

  After completion of the analysis, end the SCANOR program
  \verbatim
  SCANOR->end
  \endverbatim
  You are now ready to take a look at your output in DAMM. This concludes the
  main part of the tutorial.

  \subsection qs-end Summary
  This should complete the basics on how to setup and run the code. There are a
  variety of histograms predefined in the Processors. Remember, under the new
  framework, you do not have to recompile when you are switching out Processors.
  Changes to the source code (new histograms, gates, etc.) necessitate
  compilation.
*/

/******************************************************************************/

/** \page quickstart-v1 Original Quickstart
  \section Overview
  This quickstart guide will quickly describe how to use the current pixie16
  analysis.  The guide assumes you have no desire to know how the
  analysis performs various tasks but only want to know how to make
  the program run and do something useful.  If you are unfamiliar with
  C++ please refer to the \ref primer for a description of a few
  C++ features used in the code that have no FORTRAN equivalents.
  This chapter will use a sample ldf file taken from an RMS experiment
  with a 40x40 DSSD and one MCP.  This tutorial assumes you have a
  working knowledge of the DAMM program for viewing *.his files.

  \section Compilation
  I assume that ROOT has not been installed on your computer and you do not
  want to compile with ROOT capabilities.  In this case make sure that
  declarations of USEROOT and STANDALONEROOT are commented out in
  the Makefile.
  \verbatim
  # use a "#" on the beginning of a line to comment it out of the Makefile
  #USEROOT = 1
  #STANDALONEROOT = 1
  \endverbatim

  The next flag that must be set correctly is whether your data was
  taken with the new pixie16 readout.  This readout was developed
  for the high data rates at the back of the RMS.  If you have DSSD
  RMS data taken after March 20, 2008 then it is likely you have used the
  new pixie16 readout scheme.  If so, then make sure the -Dnewreadout
  flag is set in the following line of the Makefile.
  \code
  G++FLAGS  = -O3 -Wall -Wno-deprecated -fPIC $(CINCLUDEDIRS) -Dnewreadout
  \endcode
  If you have older DSSD RMS data or beta decay spectroscopy data from
  LeRIBSS (or similar setup) then you have most likely not used the
  new readout scheme and the -Dnewreadout flag should be commented out.
   \code
  G++FLAGS  = -O3 -Wall -Wno-deprecated -fPIC $(CINCLUDEDIRS)# -Dnewreadout
  \endcode

  Also, make sure that the appropriate compilers are inserted into
  the Makefile.  The Makefile assumes that g++ (C++), gcc (C), and
  g77 (FORTRAN) compilers are present on your computer.  If your
  compilers have different names please alter the definitions inside
  the Makefile (at the location shown below) to match your system.
  \verbatim
  #--------- define compilers
  G77 = g77
  GCC = gcc
  G++ = g++
  \endverbatim
  Additionally, you must point the make file to the appropriate
  location where you have installed the static scanor libraries.
  The ones needed are scanorlib.a, orphlib.a, acqlib.a, and ipclib.a.
  Alter locations of these static libraries by changing the definitions
  of DIRA2 and DIRB in the Makefile
  \verbatim
  DIRA2=/usr/hhirf/g77
  DIRB= /usr/acq2/lib

  LIBS = $(DIRA2)/scanorlib.a \
         $(DIRA2)/orphlib.a \
         $(DIRB)/acqlib.a  $(DIRB)/ipclib.a
  \endverbatim

  If you do not have these libraries then please visit the HRIBF
  computing web page to download the appropriate packages.

  Compile the code with the command
  \verbatim
  make
  \endverbatim

  \section inputprep Input Preparation
  In order to successfully run the pixie16 analysis two initialization
  files are required, map.txt and cal.txt.  map.txt describes the
  mapping of pixie16 input channels to specific detectors and cal.txt
  sets the calibration for each detector.  Both files are included in
  the tutorial directory and should be copied to the main scan_c++
  directory to run this tutorial.  Both files are described in
  more detail below.

  \subsection maptxt Map.txt
  The file map.txt contains a total of 7 parameters for each pixie16
  channel.  The 7 parameters are necessary for completely specifying
  the detector plugged into that channel.  The 7 parameters are:
  - module number
  - channel number
  - damm id - this is the spectrum number that the raw energies from this
        channel will be plotted.
  - detector type - this is used to logically group detectors.  For example, all
        front channels on the DSSD have a detector type of dssd_front.
  - detector subtype - this is useful in the program if you need the data from
        a specific channel you can address it by name.  For example, the first
        channel of a position sensitive MCP would be 1position1.
  - detector location - this is the physical location of the detector.  For the
        dssd this is the strip number.
  - trace - this variable is obsolete.

  Comments in the map.txt file are always preceded by "//".  An example
  of the map.txt file for use at the RMS with a DSSD and one MCP would
  look like this:
  \verbatim
  //example map.txt file
  // mod id  chan id  damm    det_type   det_subtype  det_loc  trace
          0        0   600  dssd_front    dssd_front        0      1
          0        1   601  dssd_front    dssd_front        1      1
          0        2   602  dssd_front    dssd_front        2      1
          0        3   603  dssd_front    dssd_front        3      1
          ...
          4        0   900   dssd_back     dssd_back        0      1
          4        1   901   dssd_back     dssd_back        1      1
          ...
          5        0   927         mcp    1position1        0      1
          5        1   927         mcp    1position2        0      1
          5        2   927         mcp    1position3        0      1
          5        3   927         mcp    1position4        0      1
          ...
  \endverbatim
  If a channel is not used in the experiment or is not required in the
  analysis the detector type and detector subtype should be set to
  "ignore" in the map.txt line corresponding to that module and
  channel number.  To ignore the 0 and 1 channel on module 2 the
  map.txt file would look like:
  \verbatim
  //example map.txt file ignoring module 2 channels 0 and 1
  //mod id   chan id  damm    det_type   det_subtype  det_loc  trace
         0         0   600  dssd_front    dssd_front        0      1
         0         1   601  dssd_front    dssd_front        1      1
         0         2   602  dssd_front    dssd_front        2      1
         0         3   603  dssd_front    dssd_front        3      1
         ...
         2         0   900  ignore            ignore        0      1
         2         1   901  ignore            ignore        1      1
         ...
  \endverbatim

  \subsection caltxt Cal.txt
  The other necessary file for running the program is cal.txt.  As the
  name suggests this file contains the calibration parameters for the
  detectors used in the analysis. For each channel that was defined in
  map.txt that is not set to "ignore" a line must be present in cal.txt
  and include:
  - detector location - this is the physical location of the detector.
  For the dssd this is the strip number
  - detector type - this is used to logically group detectors.  For example,
  all front channels on the DSSD have a detector type of dssd_front.
  - detector subtype - this is useful in the program if you need the data
  from a specific channel you can address it by name.  For example, the
  first channel of a position sensitive MCP would be 1position1.
  - num cal - this is the number of calibrations that will be used for this
  particular channel and can be any positive number.
  - poly order - this is the polynomial order of all calibrations for this
  channel.  1 is linear, 2 is quadratic ...
  - a set of (1+ polynomial order +1) values - the first value of this set
  is the lower limit of the current calibration.  The remaining "polynomial
  order +1" parameters are the coefficients for the  polynomial equation
  from lowest order to highest.  For example, a calibration with one 2nd order
  polynomial would have 4 values.  A calibration line with two 4th order
  polynomials would have two sets of 6 calibration parameters.

  There is currently no default calibration parameters for detectors.
  Only channels set to "ignore" have default parameters.  The upper
  limit of the calibration (exclusive) is either (1) the lower limit
  of the next calibration or (2) the maximum value set by MAX_PAR in the
  'param.h' file.  Comments in the cal.txt file are always preceded by "//".
  An example of the cal.txt file for one 2nd order polynomial looks like this:
  \verbatim
  //example cal.txt file for 1 - 2nd order polynomial
  //det    det    det   num   poly    low   cal val  cal val  cal val
  //loc   type    sub   cal  order  range     inter    slope     quad
      0   dssd   dssd     1      2    0.0     0.0        1.0      0.0
         front  front
      1   dssd   dssd     1      2    0.0     0.0        1.0      0.0
         front  front
  ...
  \endverbatim

  An example of a calibration file for two 2nd order polynomials is
  shown below.  The first calibration ranges from 0.0 to 16000.
  The second calibration has a range from 16000 to the maximum set by
  MAX_PAR in the 'param.h' file.
  \verbatim
  //example cal.txt file for 2 - 2nd order polynomials
  //det    det    det   num   poly    low    cal   cal   cal   low    cal   cal   cal
  //loc   type    sub   cal  order  range  inter slope  quad        inter slope  quad
      0   dssd   dssd     2      2    0.0    0.0   1.0   0.0 16000    0.0   1.0   0.0
         front  front
      1   dssd   dssd     2      2    0.0    0.0   1.0   0.0 16000    0.0   1.0   0.0
         front  front
  ...
  \endverbatim

  \section eventcreat Event Creation
  Events are created by grouping together channels which triggered at
  similar times.  This time window is controlled by the variable "eventWidth"
  in PixieStd.cpp in ScanList(). A list of channels sorted by time from
  lowest to highest is scanned in this function from beginning to end.
   If two successive channels in the list are within "eventWidth" time,
   they are grouped together in an event.  The variable is in units of
   pixie16 clock ticks and must be multiplied by 10 to obtain the
   event width in ns.  Please note that the "eventWidth" time
   window is only applied to successive events.  Thus it is possible
   (depending on the total trigger rate) to have events that are longer
   than the specified time window.

  \section eventret Retrieving Information from the Event
  After an event has been created it is sent for processing.  The first
  step of processing is to calibrate the individual channels and summarize
  the information contained in the event.  For each detector type that is
  present in the event an object called DetectorSummary is created.
  This object holds detector related information such as the location of
  the maximum energy deposition and the multiplicity of the detector among
  other things.  For example, the following command will retrieve
  the maximum energy that was deposited in the front of the DSSD in this
  event.
  \code
  int maxe = revt.GetSummary("dssd_front")->GetMaxEvent()->GetEnergy();
  \endcode
  where revt is the name of the variable holding the raw event information
  and maxe will contain the maximum energy deposited in the front of the
  detector.  Similarly, the strip number where the maximum energy was
  deposited is retrieved with the following command:
  \code
  int stripno = revt.GetSummary("dssd_front")->GetMaxEvent()->GetLocation();
  \endcode
  Therefore a plot of strip number versus energy for the front of the DSSD
  can be obtained by plotting the variable stripno against maxe (using the
  syntax described later in the plotting section).

  To retrieve the multiplicity associated with the front of the DSSD
  the following command is used
  \code
  int fmult = revt.GetSummary("dssd_front")->GetMult();
  \endcode

  If you already have a pointer to the detector summary of interest then
  the multiplicity could be retrieved using the pointer itself as follows
  \code
  int fmult = pdet_s->GetMult();   or
  int fmult = pdet_s.GetMult();
  \endcode
  where pdet_s is a pointer to the detector_summary and the choice between
  a "->" or "." depends on whether pdet_s is a pointer by value or
  pointer by reference, respectively.  The reference manual can provide
  a list of all commands to retrieve information from the detector_summary
  or the rawevent.

  \section Plotting Plotting
  All plotting is controlled through the "plot" function defined in
  DeclareHistogram.cpp.  This function is a C++ wrapper that has been
  placed around the DAMM count1cc and set2cc subroutines.  This allows for
  the code to be easily changed between damm and ROOT histograms.  For
  those using DAMM to view the output of the analysis all plots are created
  in the "drrsub.f" file located in the scan directory.
  For example, to plot a one dimensional histogram of energies into a DAMM
  spectrum numbered 101 the command would be
  \code
  plot(101,energy);
  \endcode
  You can send any type of numerical value to the plot function.  The
  variable is cast into an integer before being passed to the DAMM
  plotting functions.
  A two dimensional histogram is plotted with the command
  \code
  plot(101,energy,stripno);
  \endcode
  and a three dimensional histogram (plotting a trace for example) uses
  the command
  \code
  plot(101,xval,row,traceval);
  \endcode

  \section programexec Program Execution
  After compilation the executable pixie_ldf_c will be present.  Run
  the pixie_ldf_c program as you would any other scan program as follows
  \verbatim
  ./pixie_ldf_c hisname
  \endverbatim
  Where "hisname" is the name of the damm histogram that will be created.

  For this exercise you will use the tutorial.ldf file located in the
  LDF directory. At the scanor prompt load in the appropriate ldf file
  as follows
  \verbatim
  SCANOR->file tutorial/tutorial.ldf
  \endverbatim
  Next start the analysis with the following command
  \verbatim
  SCANOR->go
  \endverbatim

  After starting a variety of output should be printed to the screen.
  The first lists all the detectors that are being used in the analysis.
  For the tutorial file the dssd_front, dssd_back, and mcp detector
  types are used in
  the analysis.  Next is a list of all module and channel number
  combinations and their respective calibrations.  As a sanity check the
  total number of channels that the code has identified is given and should
  be equal to the number of %calibration lines.  Lastly, when
  new detectors are added to the code the number of possible detectors is
  given from two places in the code and the numbers should be identical.

  After completion of the analysis, end the SCANOR program
  \verbatim
  SCANOR->end
  \endverbatim

  Start damm and open your histogram.  You can display 741, 742, 743, and
  744 to see the strip versus energy profile of the dssd for implants and
  decays on the front and back of the dssd.  Spectrum 923 provides a 2D plot
  of the position sensitive MCP.

  These spectra are filled following the experiment specific event processing
  in the DetectorDriver (defined in DetectorDriver.cpp) by invoking
  the appropriate plotting routines. The 741, 742, 743, and 744 spectra are
  all filled using the DssdProcessor object and mcp 923 spectrum is filled
  by the McpProcessor object.  The plotting routines of these objects
  are invoked from the DetectorDriver in each EventProcessor's
  individual Process() functions.

  To create a decay multiplicity spectrum for the front of the DSSD you need
  to first create the spectrum and fill it in DssdProcessor.cpp.
  Create the spectrum in DeclarePlots() by inserting the following line
  \code
  DeclareHistogram1D(1743, 64, "DSSD decay front mult", 2, 64, 0, 63);
  \endcode
  or more simply (using assumed parameters):
  \code
  DeclareHistogram1D(1743, 64, "DSSD decay front mult");
  \endcode
  Fill the decay front multiplicity spectrum by going inside the the
  "if(type == decay)" and "if(side == front)" condition and inserting
  the following line after the filling of spectrum 743.
  \code
  plot(1743,frontSummary->GetMult());
  \endcode

  Save the two files and recompile the pixie16 scan program and rerun the
  analysis on tutorial.ldf.  Open the resulting damm file and you should
  have a new multiplicity spectrum.

  Next create a decay multiplicity 2 gated version of spectrum 743.  First
  create the new spectrum in DeclarePlots() by inserting the following line
  \code
  DeclareHistogram2D(2743, 8192, 64, "DSSD Strip v E-DF, mult2",
                     2, 8192, 0, 8191, 64, 0, 63);
  \endcode
  or once again:
  \code
  DeclareHistogram2D(2743, 8192, 64, "DSSD Strip v E-DF, mult2");
  \endcode

  Next insert the filling command inside the ''if(type == decay)`` and
  ''if(side == fbcoin)'' condition.
  \code
  if(frontSummary->GetMult()==2)
    plot(2743,frontSummary->GetMaxEvent()->GetEnergy(),
              frontSummary->GetMaxEvent()->GetLocation());
  \endcode

  Save, recompile and rerun the analysis and you should now have a
  multiplicity 2 gated 743 spectrum in spectrum 2743.

  \section commonerr Common Errors
  To familiarize yourself with some of the more important workings of
  the code we will now perform a few common tasks that will result in
  the failure of the analysis code.

  \subsection mapprob Problems with map.txt
  The easiest mistake is misspelling the detector name.  Open the file
  map.txt and change the entry for module 0 channel 15 to the following
  \verbatim
  //example incorrect map.txt file
  // mod id  chan id  damm    det_type   det_subtype  det_loc  trace
          ...
          0       15   616    dssd_fro    dssd_front       16      1
          ...
  \endverbatim
  This type of error will be caught by the scan program and the following
  warning will be issued.
  \verbatim
  The detector called ``dssd_fro'' read in
  from the file map.txt is unknown to this program!
  This is a fatal error.  Program execution halted.
  If you believe this detector should exist please
  edit the 'GetKnownDetectors' function inside the
  'DetectorDriver.cpp' file.

  The currently known detectors include:
  dssd_front, dssd_back, ge, timeclass, si,
  position, ifront_dssd, scint, mcp
  \endverbatim

  This warning states that you are trying to use a detector (dssd_fro) for
  which no default behavior has been assigned.  This error is the likely
  result of a misspelling and the valid detector names are listed as well.
  If you need to add a new detector type please refer to ***.  Note: the
  program does not check to make sure that the detector subtype is spelled
  correctly.  Therefore if you have code that makes use of this information
  (the MCP is one example) then make sure the spelling is consistent
  between map.txt and the analysis code.

  \subsection calprob Problems with cal.txt

  The next common error is not having the correct number of lines in the
  calibration file.  Open cal.txt and change the calibration line for
  dssd_front strip number 16 to the following
  \verbatim
  //example cal.txt file for 1 - 2nd order polynomial
  //det    det    det   num   poly    low   cal val  cal val  cal val
  //loc   type    sub   cal  order  range     inter    slope     quad
     15   dssd   dssd     1      2    0.0     0.0        1.0      0.0
         front  front
  \endverbatim
  Now you should have two lines referring to dssd_front strip number 15.
  Trying to run with this cal.txt produces the following error.
  \verbatim
  The entry in map.txt with det_type = dssd_front
  det_subtype = dssd_front
  and det_location = 16
  was not found in the cal.txt file, please fix this
  Program terminating
  \endverbatim
  All entries in the map.txt file should have a corresponding entry in the
  cal.txt file.

*/

/******************************************************************************/

/** \page timecal Time Calibrations and VANDLE Setup
  Here we will outline the details of the Time Calibrations that you will need
  to setup for a VANDLE experiment. These parameters are still being actively
  developed and will likely change in the future. See the relevant pages on
  the \subpage xmlconfig to learn how to set these various parameters.

  Here is a list of the parameters that are used for the corrections:
   - lrtoffset : The left-right time offset in ns
   - tofOffsets : time offset w.r.t. start number X in ns
   - xOffset : offset between the center of the bar and the source in cm
   - z0 : the perpendicular distance between the bar and source in cm
   - z0Offset : additional corrections to z0 in cm
   - r0 : The distance between source and the hit location in the bar in cm.
          This quantity is calculated in the code from z0, the speed of light
          in the bar, the time difference in the bar and the xOffset.

  Below we show the physical arrangement of the offsets:
  \image latex timingCorrection.eps "Diagram for the timing correction " width=3.5in
  \image html timingCorrection.jpg
*/

/******************************************************************************/

/** \page xmlconfig XML Based Configuration File
  The configuration of the code is now handled solely through an XML file. The
  old style of map files have been deprecated and are no longer supported in
  the main versions of the code. We summarize here the various sections of
  the configuration that you will encounter. There is an example configuration
  file: config/Config.xml.example.

  \section xml-setup Link the proper Config.xml
  The Config.xml file is a symbolic link to one of the various configuration
  files in the config directory. In order to switch to different configurations
  you simply need to issue the following command:
  \code
  ln -s -f config/Config.xml.example Config.xml
  \endcode
  This will point the Config.xml link to the proper configuration file.

  \section xml-guts The Guts of the Config.xml
    \subsection xml-author Author Information
        Put your name, email and date (please use Jan, Feb, ..., Dec
        for months names).
    \subsection xml-desc Description
        Put short description of your experiment here.
    \subsection xml-global Global Configuration Settings
    Global scan parameters are setup here.
    Required fields are:
    - Revision : \code <Revision version="X"/> \endcode
        where X is A, D or F
    - EventWidth : \code <EventWidth units="x" value="y"/> \endcode
        where unit must be s, ms, us or ns; value is floating point
    - EnergyContraction : \code <EnergyContraction value="x" /> \endcode
        OBSOLETE, please do not use energy contraction (consider calibration
        instead), however if needed for backward compatibility put here
        floating point number
    - Path : \code <Path>relatative_path</Path> \endcode
        where 'relative_path' is a path to the other configurations
        files not included into this xml document. At the moment only qdc.txt
        is not incorporated into this file. relative_path must end with '/'
        unless is empty (which then points to the current directory).
    - NumOfTraces : \code <NumOfTraces value="x" /> \endcode
        where x is unsigned integer giving the maximum number of traces in 2D
        traces histograms. This number is rounded up to the power of 2, since
        DAMM histograms must have such sizes

    \subsection xml-ignore Rejection Regions
    The Reject node isn't for people who have flunked out, but for the rejection
    of specific time regions of the LDF. For example, if the beam cut out at the
    end of your run but still want to use the first five minutes you can define
    \code <Time start="300" end="16000"/> \endcode
    The program will now ignore everything after 300 seconds of the file.

    \subsection xml-dd DetectorDriver Setup
    You will set up the various processors and analyzers in this node. To add
    a new processor to the analysis:
    \code <Process name="SomethingProcessor"/> \endcode
    Similarly for an analyzer :
    \code <Analyzer name="SomethingAnalyzer"/> \endcode
    Simply repeat this process for each Processor and Analyzer that you would
    like to add.

    List of known Processors:

    - BeamLogicProcessor
    - BetaScintProcessor
    - DoubleBetaProcessor
    - DssdProcessor
    - GeProcessor
        - optional attributes and their default values:
            - gamma_threshold="1.0"
            - low_ratio="1.0"
            - high_ratio="3.0"
            - sub_event="100e-9"
            - gamma_beta_limit="200e-9"
            - gamma_gamma_limit="200e-9"
            - cycle_gate1_min="0.0"
            - cycle_gate1_max="0.0"
            - cycle_gate2_min="0.0"
            - cycle_gate2_max="0.0"
    - GeCalibProcessor
        - optional attributes and their default values:
            - gamma_threshold="1.0"
            - low_ratio="1.0"
            - high_ratio="3.0"
    - Hen3Processor
    - ImplantSsdProcessor
    - IonChamberProcessor
    - LiquidScintProcessor
    - LogicProcessor
    - McpProcessor
    - MtcProcessor
        - optional attributes and their default values:
            - double_stop="False"
            - double_start="False"
    - NeutronScintProcessor
    - PositionProcessor
    - PulserProcessor
    - SsdProcesssor
    - TriggerLogicProcessor
    - VandleProcessor
        - Required Attributes and their Default Values:
            - bars="small" (CSV list, uses small,medium,big)
            - NumStarts="2" (the number of start detectors you have)
            - res="2" (sets the resolution of the time histograms to 0.5 ns/bin)
            - offset="200" (sets the arbitrary zero of the histogram to 200)
    - RootProcessor (Requires the USEROOT compiler flag)

    List of known Analyzers:
    - TraceFilterer
        - mandatory attributes and their default values:
            - gain_match="1.0"
            - fast_rise="10"
            - fast_gap="10"
            - fast_threshold="50"
            - energy_rise="50"
            - energy_gap="50"
        - optional attributes and their default values:
            - slow_rise="20"
            - slow_gap="20"
            - slow_threshold="10"
    - DoubleTraceAnalyzer
        - see TraceFilterer
    - TauAnalyzer
    - TraceExtractor
    - WaveformAnalyzer
    - FittingAnalyzer (requires PULSEFIT compiler flag in Makefile)
    - CfdAnalyzer

    \subsection xml-map Channels map
    This section replaces the map.txt (map2.txt) and cal.txt
    files. For each channel in each module that you want to use in
    analysis you must assign some physical detector type (and subtype)
    which is known to the pixie_scan (see DetectorLibrary.cpp).
    A channel may be also calibrated (by default a raw channel number
    from adc is used) or corrected against walk (by default walk
    correction is equal to 0).

    The root element (\<Map\>) may have attributes changing the verbosity
    level during loading of the configuration in this section :
        - verbose_map - output loaded modules and channels
        - verbose_calibration - Output energy calibration information
        - verbose_walk - Output walk correction information

    Each attribute default to False, if change to True will show more
    messages concerning loaded parameters etc.

    \subsubsection xml-cals Calibrations
    -Energy :
        - raw : non-calibrated (also used when no calibration specified)
        - off : turn channel off (returns always 0)
        - linear : requires 2 parameters
        - quadratic : requires 3 parameters
        - cubic : a third order polynomial correction, requires 4 parameters
        - polynomial : more general but slightly slower then the
            two above : requires at least 1 parameter
        - hyplin : f(x) = a0/x + a1 + a2*x , suitable if problems with
            low channels are encountered - requires 3 parameters

    -Time Walk :
        - None : returns always 0
        - A : f(x) = a0 + a1 / (a2 + x) + a3 * exp(-x/a4), derived for
            the ge detectors at 85-86Ga experiment - requires 5 parameters
        - B1 : f(x) = a0 + (a1 + a2 / (x + 1)) *  exp(-x / a4)
            This model was developed for the ge detectors at 93Br
            experiment. Use it for the low energy part of spectra. For
            the high energy part use B2 model.
        - B2 f(x) = a0 + a1 *  exp(-x / a2)
            This function is the second part of 'B' model developed
            for the 93Br experiment
    Note that walk models parameters are intended to operate on natural
    units i.e. raw channel numbers and pixie time tics.

    Both calibration and walk correction operate on some range and
    there might be any number of ranges defined for the channel.
    The code does not check if a range overlaps with another. For a given
    channel number the first (in order of appearance) matching range will be
    used.

    If no min/max is specified, a 0 to infinity range is assumed (where
    infinity is a largest double precision floating point number on a
    given machine).

    \subsubsection xml-mapex Map Example
    An example below shows the main features of the Map node.
    \code
    <Map verbose_map="True" verbose_calibration="True" verbose_walk="True">
        <Module number="0">
            <Channel number="0" type="ge" subtype="clover_high">
                <Calibration model="quadratic" min="0" max="100">
                    -0.912 0.625 1.2390e-5
                </Calibration>
                <Calibration model="linear" min="100">
                    0.1 0.515
                </Calibration>
                <WalkCorrection model="A">
                    2.322 12487.727 432.257 19.268 140.189
                </WalkCorrection>
            </Channel>
            <Channel number="1" type="beta_scint" subtype="beta" location="5"
                    tags="12,3,first">
            </Channel>
            ...
        </Module>
        <Module number="1">
            ...
        </Module>
            ...
    </Map>
    \endcode

    \subsection xml-tcal Time Calibrations
    See the \ref timecal section for more detailed information about the
    various parameters in this calibration.

    The time calibrations are for the alignment of detectors that use the
    high resolution timing algorithms in space and time. This includes all the
    VANDLE Bars, liquid scintillators, etc. Eventually, this will be updated
    and expanded based on different VANDLE orientations (i.e.
    parallel/perpendicular to beam).

    NOTE: We currently do no error checking to make sure that an equivalent
    bar is defined in the Map. In such an event the code will simply return a
    calibration of zero for all of the possible corrections.
    \code
    <TimeCalibration verbose_timing="False">
        <Vandle>
            <small>
                <Bar number="0" z0="50.5" xoffset="1.0" zoffset="0.00"
                    lroffset="-5.70784">
                    <start loc="0" offset="2.90192"/>
                    <start loc="1" offset="-6.52371"/>
                    <start loc="2" offset="1.23556"/>
                    <start loc="3" offset="-5.56573"/>
                </Bar>
                <Bar number="1" z0="11.0" xoffset="1234.0" lroffset="-244.0" />
            </small>
        </Vandle>
        <Scint>
            <liquid>
                <Detector number="0" r0="0.0" xoffset="0.0" lroffset="0.0"
                     tofoffset0="0.0" tofoffset1="0.0" />
            </liquid>
            <start>
                <Detector number="0" r0="0.0" xoffset="0.0" lroffset="0.0"
                     tofoffset0="0.0" tofoffset1="0.0" />
            </start>
        </Scint>
    </TimeCalibration>
    \endcode

    \subsection xml-treecorr Tree Correlator Information
    Create here tree of "places" build of \<Place\> elements for
    your experiment. Basic places are created automatically from entries
    in the Map section using type_subtype_location pattern.

    Root element should be named \<TreeCorrelator\>.
    Each \<Place\> element has a following attributes:
        - 'name' : required, if last token in name
                    (tokens are separated by '_')
                    characters are in format X-Y,Z where X, Y and Z
                    are integers, a whole range X to Y is assumed
                    (e.g.  beta_0-1,5,9-10
                    will create beta_0, beta_1, beta_5, beta_9 and beta_10 )
        Optional attributes:
        - 'type' : must be one of types defined in PlaceBuilder.cpp
                     (see there) currently available are:
                    PlaceDetector, PlaceThreshold, PlaceThresholdOR,
                    PlaceCounter, PlaceOR, PlaceAND
                    if type is not used or empty (type="") it is assumed that
                    place already exists. In particular this is true for all
                    basic places created from channels as defined from Map
        - 'replace' : if set to 'true', will replace existing place with a
            one defined in this element.
        - 'fifo' : depth of FIFO of place
        - 'coincidence' : defines type of relation with parent (true of false)
        - 'low_limit', 'high_limit' : required for PlaceThreshold and
                PlaceThresholdOR defines threshold limits
                (calibrated energy).

    See PlaceBuilder for other type of places and attributes.

    \subsection xml-notes Notebook
    Configuration of Notebook object that saves handy notes (things that are
    not easy to present on graph e.g. single event details) file - file in
    which the notes are saved mode - 'a' for append, 'r' - for replace mode
*/

/******************************************************************************/

/** \page treecorr Tree Correlator
  The TreeCorrelator has been documented extensively in the documentation file:
  doc/guides/treeCorrelatorNotes.pdf. In addition, you can find some
  documentation in the \ref xml-treecorr section. The most help will be gained
  from the classes related to the tree correlator, specifically Place,
  PlaceBuilder, and TreeCorrelator.
*/

/******************************************************************************/

/** \page refman Reference Manual
  - An \subpage introduction to the pixie16 analysis
  - A list of \subpage dettype used in the analysis
  - A list of \subpage objects (both detector and others) used in the analysis
  - Experiment Independent Event Processing
       -# \subpage %PixieStd
       -# \subpage %DetectorDriver
  - Experiment Dependent Event Processing
       -# \subpage leribss
       -# \subpage RMS
  - A list of \subpage changes-v3 in the most recent version
*/

/******************************************************************************/

/** \page DetectorDriver Event Processing - DetectorDriver
  This page describes the aspects of DetectorDriver.cpp used for the RawEvent
  which remain consistent between experiments and includes five different
  main functions
  - Init() - initialize the detector driver
  - ProcessEvent() - processes a complete event passed from ScanList()
  - ThreshAndCal() - check threshold and calibrate the raw channel energies
  - PlotRaw() - plot raw experimental energies
  - PlotCal() - plot calibrated energies

  \section dd-init Initialization
  The DetectorDriver initialization routine
  (DetectorDriver::Init()) is called with the detector types that have
  been identified from the event. It then initializes the necessary Analyzers
  and Processors, reads in the energy Calibration and the Walk correction, and
  finally initializes the Correlator. The Init methods for the Analyzers and
  Processors are contained in their own codes.

  \subsection ReadCal
  The calibrations are read in during the detector driver
  initialization (DetectorDriver::ReadCal()) from the file Config.xml.
  Please see \subpage xmlconfig Configuration for detailed information.

  For each channel with a calibration the type of calibration, and the
  calibration parameters are read. They are then added to the list of
  calibrations. If there is no calibration, then any calls for this channel to
  calibrate the energy returns the energy.

  \section ProcessEvent
  ProcessEvent() accesses the global RawEvent and processes it. It first
  plots the raw and calibrated energy along with performing the calibration and
  threshold. It then performs two loops over the data.

  The first loop is the PreProcees loop. This loop will call the PreProcess
  method for each of the used processors. The work done in the PreProcess
  methods __should not__ depend on the results of other Processors.

  The second loop calls the main "Process" method for each of the Processors.
  The work done in these methods may depend on the results from other
  Processors. This is where the main work of the Processors will be done.

  \subsection ThreshAndCal
  ThreshAndCal() receives a pointer to the current channel event. It then
  proceeds to set values that are calculated from the traces (qdc, phase, etc.).
  This is also the point at which the energyContraction is applied to the
  energies. Finally, it applies the energy calibration and walk corrections.

  \subsubsection Trace
  If a trace is included with the channel object then the trace
  analysis is invoked through the TraceAnalyzer.

  \subsection PlotRaw
  The raw energy from the channel is plotted into the appropriate
  damm spectra as long as it was created in DeclareHistogram.cpp

  \subsection PlotCal
  The calibrated energy from the channel is plotted into the
  appropriate damm spectrum if it was created in DeclareHistogram.cpp
*/

/******************************************************************************/

/** \page dettype Detector Types
  This page describes all detector types that are possible
  to use in the current analysis.  These are the only
  detector types that are valid for use in the Config.xml file.

  \section dt-hen 3hen
  This detector type is used for the 3Hen detector. This is processed by the
  Hen3Processor.

  \section beta_scint
  This detector type is for scintillator detectors used to detect beta
  particles. This is processed by BetaScintProcessor.

  \section dssd_front
  This detector type is used for the front of the DSSD.  The front
  and back of the DSSD must be kept separate to independently determine
  the strip with the maximum energy for front and back.  Available
  sub types include:
  - dssd_front
  This is processed by DssdProcessor.

  \section dssd_back
  This detector type is used for the back of the DSSD.  Available
  sub types include:
  - dssd_back
  This is processed by DssdProcessor.

  \section ge
  This detector type is used for all germanium detectors.  The
  clover detectors are the furthest developed at present.  Available
  sub types include:
  - clover
  - sega
  This is processed by GeProcessor.

  \section generic
  This is a detector type for a generic detector. It could be something that
  you do not need a full processor for, and simply want to have access to the
  detector information. There is no dedicated processor.

  \section idssd_front
  This detector type is for the front of the dssd for implants only.
  This type is intended for use in fragmentation experiments where
  the implant and decay signals use two separate electronics chains.
  Available sub types include:
  - idssd_front

  Handled by the ImplantSsdProcessor.

  \section ignore
  This type will be ignored at every step of the analysis.

  \section ion_chamber
  This type is for an ion chamber. It is handled by the IonChamberProcessor.

  \section liquid_scint
  This detector type is for liquid scintillator detectors. This is processed by
  LiquidScintProcessor.

  \section logic
  This detector type is for Logic signals from traditional electronics. These
  types are handled by the LogicProcessor.

  \section mcp
  This detector type is for all mcp detectors.  Available sub types
  include:
  - 1position1 - MCP position signal 1.
  - 1position2 - MCP position signal 2.
  - 1position3 - MCP position signal 3.
  - 1position4 - MCP position signal 4.
  - 1time - MCP timing signal.
   This is processed by McpProcessor.

  \section mtc
  This type is for the signals from the Moving Tape Collector (MTC). This stuff
  is handled by the MtcProcessor.

  \section neutron_scint
  This detector type is for scintillator detectors used to detect neutrons.
  This is processed by NeutronScintProcessor.

  \section position
  This detector type is for a position signal at a fragmentation experiment.
  This type is intended for correcting a time-of-flight signal based
  on the position signal at an intermediate focus.  Available sub types
  include:
  - i2spos

  Handled by the PositionProcessor

  \section pulser
  This type is for simple pulsers. It is mainly designed for measuring the
  time difference between the subtype "start" and "stop". Handled by the
  PulserProcessor.

  \section si
  This detector type is for all silicon detectors that are not a
  DSSD.  This type should be used for the silicon box. No sub types
  for this type yet.

  \section ssd
  A type for an SSD. This is handled by the SsdProcessor.

  \section timeclass
  This detector type is for timing detectors such as TACs and MTCs.
  Available sub types include
  - MTC (processed by MtcProcessor)

  \section tvandle
  A detector type for a "Teeny VANDLE" detector. Currently, handled by the
  VandleProcessor, but will have its own at some point.

  \section vandle
  A type for all types of VANDLE bars, different sizes are handled via the
  subtypes: small, med, big. Handled by the VandleProcessor.
*/

/******************************************************************************/

/** \page introduction Introduction
  There are two main files which control the pixie16 analysis flow,
  PixieStd.cpp and DetectorDriver.cpp both of which are located
  in the src directory.  The functions in PixieStd.cpp reconstruct a
  complete data spill from the pixie16 modules and, for each spill,
  create a list of channels that triggered.  The list is then sorted
  according to time and those channels which occur close to each other
  in time are grouped together into events.  The event is then passed
  into DetectorDriver.cpp for processing.

  DetectorDriver.cpp receives each event and calibrates the energy for
  each channel in the event.  The raw and calibrated energies are plotted
  if the appropriate damm spectra have been created in DeclareHistogram.cpp.
  Lastly, experiment specific analysis is performed.
*/

/******************************************************************************/

/** \page leribss LeRIBSS Experiments
  This page describes the experiment specific analysis that is
  conducted when running a beta decay experiment with the MTC. Usually, this
  type of experiment was done at LeRIBSS.

  __Still needs to be updated__

  \section detreq Detector Types
  For an MTC experiment the following detector types and sub types
  are used.
  - beta_scint
  - mtc
  - ge - clover - a set of clover detectors for gamma ray detection.

  \section logproc Event Processing
  The MTC, MCP, and beta detectors are checked to see if any of them
  fired in the event.  If any of the three detectors fired the time
  of the respective channel is retrieved.

  \section leribss-corr Correlations
  You should setup the TreeCorrelator appropriately to make sure that you
  correlate the beamOn/Off information with your decays.
*/

/******************************************************************************/

/** \page changes-v3 Changes for Version 3
    We will not list all of the changes that have been made in this version.
    The git repository history will do that for us.

    For changes in the previous version, see \subpage changes-v2.
*/

/******************************************************************************/

/** \page changes-v2 Changes for Version 2
    \section sec-general General changes
    - Consistency in the naming conventions of variables/classes included in the
        code
    - Names made more descriptive when necessary
    - Prevent as much copying of information between classes for optimization
    - Old ROOT-style functionality currently unimplemented
    - C++ streams used instead of stdio functions as much as possible
    - Comments improved -- simple coding statements within comments removed
    - Unused variables removed, or commented out when the extension of the
        program to include their eventual use is evident
    - Classes are more const correct and therefore users shouldn't be able to
        mess up things that they shouldn't touch

    \section sec-correlator Correlator.cpp
    - Previously called \c correlator.cpp
    - Header now includes correlation structures
        (previously in \c raw_event.cpp) with different structures for implants
        and decays
    - Now only one main correlation function exists
    - DSSD decay spectra plotting now located in DssdProcessor.cpp

    \section sec-histo DeclareHistogram.cpp
    - New set of global functions which take over the behaviour of \c drrsub.f
    - Main plotting functions and generic low-level histogram definitions
        defined here
    - All used DAMM plot ids defined in damm_plotids.h
    - No DSSD strip spectra automatically defined

    \section sec-driver DetectorDriver.cpp
    - \b Major changes
    - Previously called \c detector_driver.cpp
    - Calculation of calibrated energies now in Calibration class
    - Significant reduction of members of DetectorDriver
    - Simple sanity check function to be run at beginning of analysis
    - Most of analysis is now done through a vector of event processors
    - Raw event is now accessed globally
    - Calibrated spectra are now defaulted to damm id# \f$200+ch\f$
    - Calbrations are now matched to the channel identifiers so only one
        consistent reading of \c map.txt is done
    - Random number initializations now done here and are scaled appropriately
        by the contraction factor of the Pixie energies
    - A local copy of the analysis' used detectors is no longer made
    - Detector summaries have been moved to the RawEvent class
    - No "temppoint" handling of detector summaries, instead each EventProcessor
        will keep its own individual map of detector summaries for the
        detectors it is interested in

    \section sec-dssd DssdProcessor.cpp
    - Previously called \c dssd_sub.cpp
    - Handles much of the correlation work that was previously done by the
        DetectorDriver
    - Decays required to be anti-coincident with MCP signals
    - Plotting for decay spectra now done here

    \section sec-event EventProcessor.cpp
    - New class which defines the generic behaviour for the processor which
        handle events for detectors of different types
    - Includes an interface to ROOT for each individual processor

    \section sec-geprocessor GeProcessor.cpp
    - Previously called \c ge.cpp
    - Number of clovers is now determined using the global vector of
        identifiers not from reading \c map.txt

    \section sec-make Makefile
    - Implicit rules used for most targets
    - REVISIOND flag added to support Pixie Rev. D modules
    - Target "dist" and "distdocs" added to make tarball of code

    \section sec-mcpx McpProcessor.cpp
    - Previously called \c mcp.cpp
    - Now includes a simple branch for "new"-style ROOT analysis

    \section sec-mtc MtcProcessor.cpp
    - Previously called \c timeclass.cpp
    - Handling of old TOF timeclass for NSCL experiments not currently
        implemented

    \section sec-pixiestd PixieStd.cpp
    - \b Major changes
    - Previously called \c pixie_std.cpp
    - Chunks starting with a -1 delimiter are now skipped over while looking
        for the beginning of a spill
    - If only the last 5-word chunk is missing from the spill, it is
        reconstructed
    - The last 5-word chunk is checked to verify that it is the last chunk
        expected for the spill
    - Real, system, and user time in analysis reported occasionally
    - Random number initialization moved to DetectorDriver.cpp
    - Modules are only expected to be read out cyclically
    - Support up to 14-slot crates
    - Stand-alone ROOT support currently not implemented
    - Events now placed into the list of events using their pointers, so they
        do not need to be copied
    - Channel identification index numbers are now extracted from the module
        and channel number in \c map.txt not according to the order of
        appearance in the file
    - Multiple definitions of the same channel in \c map.txt will now produce
        an error
    - Platform independce now more obvious through definition of word_t

    \section sec-raw RawEvent.cpp
    - \b Major changes
    - Previously called \c rawevent.cpp
    - Structures for correlation now connected with Correlator.cpp
    - Actual Correlator class now included in the RawEvent
    - Channel IDs are now returned directly from the data imported from \c
        map.txt -- individual channel events do not contain their own copies
    - ID numbers are calculated (not stored) using module and channel numbers
    - Much less "structification" for channel events -- ReadBuffData() is a
        friend to set information. In particular, getting a copy of the trace
        is no longer supported as this can create a large burden on the analysis
    - Detector summaries are now stored with the RawEvent instead of in the
        DetectorDriver
    - Detector summaries now address their constituent events by pointer
        (not by arbitrary index in RawEvent)
    - One function call to handle all details regarding associating a channel
        event to a particular DetectorDriver
    - Less "structification" for the RawEvent -- access to detector summaries
        is only allowed by pointers to prevent copying of large amounts of
        channel data
    - Asking for an unexpected DetectorDriver will complain accordingly

    \section sec-buf ReadBuffData.cpp
    - A version for both Rev. A and Rev. D of the Pixie modules
    - Main function now directly takes a pointer to the beginning of the data
        to be processed of Pixie words of the appropriate size
    - Identifiers are no longer set since they are calculated dynamically in
        RawEvent.cpp

    \section sec-root RootProcessor.cpp
    - New tact of creating ROOT trees where the data is broken into its
        constituent detector parts (saved as branches) by the event processors.
        This is in contrast to the old method of saving raw event data

    \section sec-scint ScintProcessor.cpp
    - Previously called \c scint.cpp
    - If no Ge detectors are present, processor asks for a NULL detectors
        summary which has to be treated properly
    - No more triple counting for plots
    - Discombobulated in general

    \section sec-stats StatsAccumulator.cpp
    - New simple class which provides a consistent and concise way of
        calculating means and standard deviations
    - Designed to work with the STL accumulate algorithm defined in \c numeric
    - Example of use in TraceAnalyzer.cpp

    \section sec-trace TraceAnalyzer.cpp
    - Previously called \c trace.cpp
    - Better implementation of STL methods
    - Filter functions now includes a version to fill the vector in place so
        an unnecessary copy is not made
    - Processing time information is included
 */

 /******************************************************************************/

 /** \page objects Objects
  This page will describe the various objects that are used in the
  analysis.  These objects are both for detectors and processing.
  All objects are declared, initialized and used in the
  DetectorDriver class.

  __This section has not been updated yet, as the number of Processors and
  Analyzers has exploded. This list is largely unnecessary due to the automatic
  documentation placed inside of the various class implementations.__

  \section obj-detobj Detector Objects

  \subsection obj-dssd DssdProcessor
  The DssdProcessor object is intended for use with the two DSSD detector
  types dssd_front and dssd_back.  The DssdProcessor object is currently
  only used to plot DSSD spectra including the DSSD strip versus energy
  spectra (741, 742, 743, 742) and DSSD hit pattern spectra (725, 726).
  Both dssd_front and dssd_back detector types feed into this object for
  plotting.

  \subsection obj-event EventProcessor
  The EventProcessor is the generic processor from which all the others are
  derived. This allows the common process timing and setting up of the
  associated types and DetectorSummaries in a common framework.

  \subsection obj-ge GeProcessor
  The GeProcessor object is intended for use with any germanium detector.
  All detectors with a detector type of Ge feed into this object.  The
  GeProcessor object is developed for clover detectors and its two main
  functions plot germanium spectra and perform addback.

  \subsection obj-mcp McpProcessor
  The McpProcessor object is intended for use with all mcp detectors.  All
  detectors with a detector type of mcp feed into this object.
  The McpProcessor object calculates the 2D position of an event based on
  the collected charge from the four corners of the detector.

  \subsection obj-mtc MtcProcessor
  The MtcProcessor object is intended for analysis with detectors
  of type timeclass and subtype mtc (alternatively type mtc will work).
  No correlation of implants and decays is currently done, however this
  could be easily implemented through the Correlator.

  \subsection obj-root RootProcessor
  The RootProcessor object is designed to output a ROOT tree for further
  analysis. In particular, it calls the AddBranch() and FillTree() methods
  of all the EventProcessors included in the present detector driver. Note
  that this requires compilation using the USEROOT flag. Also this is a
  significant departure from the previous ROOT philosophy. In particular,
  the data is separated by its true function in the experiment and significant
  pre-processing of the data is done into what we would want to access about
  the data. Raw channel events are not dumped, but this behaviour probably
  will be again implemented soon.

  \subsection obj-scint ScintProcessor
  The ScintProcessor object is intended for use with an scintillator object
  and is fed from any detector type labeled as scint. This class was
  particularly discombobulated in the previous version of the code. At the
  moment, it only plots things for scintillators with subclass neutr.

  \subsection obj-spline SplineProcessor
  \warning In progress

  The SplineProcessor is designed to derive sub-sample timing resolution
  based on the pulse shape of the signal. Several methods are being
  investigated and this class will develop accordingly.

  \section obj-proobj Event Processing Objects

  \subsection obj-detdriver DetectorDriver
  The DetectorDriver object controls event processing.  A raw event
  is passed to it from ScanList() and all channels in the raw
  event are checked against their threshold and calibrated.
  Then the experimental processing is started.

  \subsection obj-correlator Correlator
  The Correlator object controls the correlation of decays with previous
  implants.  Two 2D arrays of size MAX_STRIP by MAX_STRIP are created
  for both implants and decays.
  Decays are correlated to implants if the time between implants was
  sufficiently large and the time between decays and implants is less
  than the correlation time.  This object also controls the plotting
  of time versus energy plots such as the 750s.

  \subsection obj-trace TraceAnalyzer
  The TraceAnalyzer object implements a quick online trace analysis
  routine based on trapezoidal filters to identify double pulses.
  The object also plots the trace spectra.

  \section obj-other Other objects
  \subsection obj-stats StatsAccumulator
  This is a utility object for finding means and standard deviations
  from an STL object using the STL accumulate() algorithm.
*/

/******************************************************************************/

 /** \page PixieStd Event Creation - PixieStd
  This page describes PixieStd.cpp used for event creation
  and should not have to be altered on a regular basis.  PixieStd
  includes five important functions which control event creation:
  - hissub_() - The interface between SCAN and the C++ analysis.
  Reassemble a complete pixie16 spill of data.
  - hissub_sec() - extract channel information from the raw Pixie16
  data spill and sort the triggered channels based on time.
  - ScanList() - Group channels into events and send to DetectorDriver
  for processing
  - HistoStats() - plot various permanent spectra such as the run
  time and time between events.

  \section pstd-hissub

  PixieStd is the interface between the HRIBF scan program and the
  Pixie16 C++ analysis.  hissub_() is called from scan
  with two variables.  The first, ibuf, is a pointer to the array
  where the raw data is stored.  The second, nhw, describes the
  amount of raw data that is stored in the array.

  In a typical experiment with the new pixie16 readout (default),
  all Pixie16 modules are read out when one module has reached its
  maximum number of events or FIFO threshold.  This is programmed
  during experimental setup.  This spill of data is divided into
  smaller chunks of data for transmission across the network.  hissub_()
  collects the chunks of data to reassemble the complete spill.

  \section hissub_sec

  Once the spill is reassembled, hissub_sec() scans the
  reconstructed buffer to extract individual triggered channels using
  the ReadBuffData() function. The individual channels are inserted
  into the list of events and once the spill has been completely scanned
  the list is sorted based on the event time of each individual channel.

  \section pstd-ScanList

  After the list of channels that triggered in the current spill has
  been sorted by time, ScanList() is called.  This function scans the
  list of channels and groups channels with similar times together into
  events. Starting from the beginning of the list and continuing to the end,
  an individual channel event time is compared with the previous channel
  event time to determine if they occur within the time period defined by
  the EventWidth variable (in units proper to the revision) and
  - if yes - the two channels are considered to belong to the same
  event and the current channel is added to the list of channels
  in rawEvent.
  - if no - the previous rawEvent is considered complete and is
  sent to the DetectorDriver for processing.  Once processing
  is finished, the rawEvent variable is cleared and the current
  channel is placed inside it to begin a new event.
*/

/******************************************************************************/

 /** \page RMS RMS
  This page describes the experiment specific analysis that is
  conducted when running a particle decay spectroscopy experiment
  at the back of the RMS.

  __This section is unchanged and may not reflect what you would like to do.__

  \section rms-detreq Detector Types
  For an RMS experiment the following detector types and sub types
  are used.
  - dssd_front - dssd_front - the front of the DSSD.
  - dssd_back  - dssd_back  - the back of the DSSD.
  - MCP - 1position1 - the first channel of the position sensitive MCP.
  - MCP - 1position2 - the second channel of the position sensitive MCP.
  - MCP - 1position3 - the third channel of the position sensitive MCP.
  - MCP - 1position4 - the fourth channel of the position sensitive MCP.
  - MCP - 1time - the timing signal of the position sensitive MCP.
  - ge - clover - Clover detectors if used.

  \section rms-logproc Event Processing
  The multiplicities on the front and back of the DSSD are retrieved
  as are the maximum energies deposited in both the front and back and
  strip numbers where it occured.  If both the energy deposited in the
  front and back is above a user defined threshold
  (variable DssdProcessor::cutoffEnergy), then the event is treated as an
  implant.  If both front and back energies are below the cutoff,
  the event is a decay.  If one is a above and the other below the event
  is called an "unknown" type.  The event is then correlated.  If only
  the front or the back fires then the energy deposited into the DSSD
  is checked against the cutoff energy but the event is not correlated.
  If the mcp fired the position is determined from the four mcp signals.

  \section rms-Plotting
  All dssd plots are filled using DssdProcessor::Process() when either
  the front or back fires. Ge signals are plotted in GeProcessor::Process()
  and the 2D mcp position spectra is plotted in McpProcessor::Process()
*/

/******************************************************************************/

/** \page devman Developer Manual (under construction)
  - A list of \subpage makeflags
  - The method for \subpage add
  - The method for \subpage addopt
  - Ideas for future \subpage improvement
  - Some \subpage nameConv for sanity
*/

/******************************************************************************/

/** \page addopt adding and using an optional detector processor
    \section addopt-intro Introduction
    We discuss here the steps one needs to follow in order to add and use an
    experiment specific detector processor. These types of Processors work in
    conjunction with their parent processors to provide additional functionality
    beyond the original processor's intent.

    For example, the use of the VandleAtLeribssProcessor is designed to add
    additional histograms, gates, and other features that need not be used in
    the original VandleProcessor. These processors may also be used to
    provide completely new functionality, while still being part of an existing
    processor.

    Not every processor is ready to be used in this way and may require some
    modifications in order to obtain this functionality. For examples of how to
    update your processors to use this feature take a look at the GeProcessor
    and the VandleProcessor.

    \section addopt-get Getting the Optional Processors
    The optional processors are kept in an additional git repository, since they
    will not all necessarily be useful to everybody who uses this software. They
    can be downloaded using the following command :
    \code
    git clone https://github.com/pixie16/ExperimentProcessors.git
    \endcode

    \section addopt-setup Setting up the Environment
    To take advantage and ease the use of these new processors, you should
    export an additional environmental variable in your .bashrc.
    \code
    export EXTRA_PROCESSORS=/absolute/path/to/extra/processors
    \endcode
    By exporting this variable, the Makefile will automatically search the
    directory for the desired files.

    \section addopt-make Setup the Makefile
    Unfortunately, we still need to add the processor to the Makefile so that
    it will be compiled and linked with the program. You should add your
    processor to the list of existing processors.
    \code
    VANDLEATLERIBSSPROCESSORO = VandleAtLeribssProcessor.$(ObjSuf)
    \endcode
    Second, you need to add the new processor to the list of CXX_OBJS
    \code
    $(VANDLEATLERIBSSPROCESSORO)
    \endcode
    You can either add it in its own line or with the other processors, it
    really doesn't matter.

    \section addopt-driv Setup DetectorDriver
    We now need to update the processor list in DetectorDriver. Since we are
    inheriting from the VandleProcessor, we will change the entry for the
    VandleProcessor directly. The code that originally looked like this
    \code
        else if (name == "VandleProcessor") {
            double res = processor.attribute("res").as_double(2.0);
            double offset = processor.attribute("offset").as_double(200.0);
            unsigned int numStarts = processor.attribute("NumStarts").as_int(2);
            vector<string> types =
                strings::tokenize(processor.attribute("types").as_string(),",");
            vecProcess.push_back(new VandleProcessor(types, res, offset, numStarts));
        }
    \endcode
    Will now look like
    \code
        else if (name == "VandleProcessor" || name == "VandleAtLeribssProcessor") {
            double res = processor.attribute("res").as_double(2.0);
            double offset = processor.attribute("offset").as_double(200.0);
            unsigned int numStarts = processor.attribute("NumStarts").as_int(2);
            vector<string> types =
                strings::tokenize(processor.attribute("types").as_string(),",");
            if(name == "VandleProcessor")
                vecProcess.push_back(new VandleProcessor(types, res, offset, numStarts));
            else if (name == "VandleAtLeribssProcessor")
                vecProcess.push_back(new VandleAtLeribssProcessor(types, res, offset, numStarts));
        }
    \endcode
    In addition, we need to add the header file to the list at the top of
    DetectorDriver.
    \code
        #include "VandleAtLeribssProcessor.hpp"
    \endcode
    \section addopt-cfg Setup the Configuration File
    Finally, we need to update the Config.xml to use the new processor instead of the
    stock one.
    \code
        <Processor name="VandleAtLeribssProcessor"
            types="small" res="2" offset="200" numStarts="2"/>
    \endcode
    This code will replace the line for the VandleProcessor in the DetectorDriver
    node.

    \section addopt-tips Tips and Tricks
    One thing to keep in mind is that the constructor for the child processor
    must accept at a minimum the same number of arguments that the parent does.
    This does not mean that you are limited in any way for a maximum.

    In this example we could have added an additional argument to the constructor
    for the VandleAtLeribssProcessor for the number of the banana that we would
    like to analyze. This argument would not need to be passed to the constructor
    for the parent.
*/

/******************************************************************************/

/** \page add adding a New Detector Processor
  This page will describe the process for adding a new Processor
  to the analysis. In principle, you can add a Processor to handle specific
  detector types, or to handle those that already exist.

  To add a new detector first a class must be constructed which
  defines its behavior by creating a .hpp and .cpp file. For example,
  the following section defines a new detector class called "Template".

  The hpp file should look something like
  \include include/TemplateProcessor.hpp

  The cpp file should look something like
  \include src/TemplateProcessor.cpp

  Once a class exists for your new detector you must create an instance of it
  in the DetectorDriver.  Include the proper file in DetectorDriver.cpp
  \code
  #include "TemplateProcessor.hpp"
  \endcode
  Be sure that you put the proper detector type into the "associated types"
  vector in the constructor. This will ensure that whenever this detector type
  is in the event the processor will be called.

  Next initialize it with the other processors in the constructor of
  DetectorDriver.
  \code
    ...
    } else if (name == "TemplateProcessor") {
            vecProcess.push_back(new TemplateProcessor());
    }
    ...
  \endcode

  Finally, your new processor simply needs to be added to the Config.xml and
  you are ready to do your analysis.

  Adding a new detector type needs only minimal additional changes to the
  DetectorLibrary. To the list of known detectors
  \code
    const unsigned int detTypes = 2;
    const string detectorStrings[detTypes] = {
        "3hen", "beta_scint", "dssd_front", "dssd_back", "ge", "generic",
        "idssd_front", "ignore", "ion_chamber", "liquid_scint", "logic",
        "mcp", "mtc", "neutron_scint", "position", "pulser", "si", "ssd",
        "timeclass", "tvandle", "vandle", "template"
    };
  \endcode
*/

/******************************************************************************/

/** \page makeflags Makefile Flags
  There are several flags in the Makefile that you can use to control the
  flow of the analysis. These include:
  - USEROOT - To use this flag, you must have installed the ROOT
    analysis package on your system and have the ROOTSYS, PATH,
    and LD_LIBRARY_PATH environment variables set correctly (according
    to the ROOT installation). This  flag compiles in the ability to
    output a .root file depending on a set of conditions in the
    RootProcessor but otherwise does not affect the functioning of the code.
  - CXXFLAGS += -DVERBOSE - This defines the VERBOSE preprocessor condition.
    Turn this on in order to have a wickedly verbose scan.
  - ONLINE - This will create a much quieter scan code. Outputting to the
    terminal takes time, and you don't always want that when running.
  - DEBUG - This will enable verbose debugging for the TreeCorrelator. It will
    be useful if there's something that's going wrong.
  - PULSEFIT - This includes the libraries for GSL necessary for the high
    resolution timing.
  - GGATES - Defines gamma gates for the GeProcessor. This turns on Gamma-Gamma
    angular distribution and Gamma-Gamma-Gamma gates.
*/

/******************************************************************************/

/** \page improvement Improvements
 - Generic processor and detector type on which the calibrator and trace
    analyzer can function
 - Optimization and clarification of TraceAnalyzer.cpp
 - Implementation of old standalone root analysis
 - Include QDC and CFD information from channel headers for Revision D
 - Gating class which can be applied to event processors
 - Expand detector summaries to work on type/subtype combinations
*/

/******************************************************************************/

/** \page nameConv Naming Conventions
 Some sort of convention -- maybe not the best, but at least it's a choice. Of
 course, these are solely a suggestion, and exceptions could occur.
 - Classes are things: "ExampleClass"
 - Variables and class members have names like "myVariable"
 - Namespaces like "thisNamespace"
 - Acronyms uncapitalized generally like "DssdProcessor" (exceptions may abound)
 - Global CONSTANT variables can have forms like "CONSTANT_VARIABLE"
 - C++ functions declared as actions: "DoSomething(...)"
 - Fortran functions called as "func_()"
 - Implementation of classes in files with the same name as the class
 - Files with extensions ".cpp", ".hpp", and ".f"
 - Generic index variables use "i,j,k" or more explicit names such as "mod, ch";
    if you need more, consider reorganizing your code
 - Enumeration types like "EColors" with members "BLUE, RED, ORANGE"
 - Typedefs with simple names like "word_t"
 - Spectrum IDs use namespaces as appropriate and constant names like "D_ENERGY"
    (1D) or "DD_ENERGY__TIME" (2D, time (y) vs. energy (x)): subject to further
    consideration
 */
